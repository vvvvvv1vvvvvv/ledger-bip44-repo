{"version":3,"sources":["ledger.js","App.js","index.js"],"names":["pathBase","hdPathString","type","BRIDGE_URL","NETWORK_API_URLS","ropsten","kovan","rinkeby","mainnet","LedgerBridgeKeyring","opts","accountDetails","bridgeUrl","page","perPage","unlockedAccount","hdk","HDKey","paths","iframe","network","implementFullBIP44","deserialize","msgQueue","isWebUSB","transport","app","Promise","resolve","hdPath","this","accounts","makeApp","_migrateAccountDetails","filter","account","Object","keys","includes","ethUtil","_isLedgerLiveHdPath","accountIndexes","bip44","_getPathForIndex","forEach","_pathFromAddress","e","console","log","Boolean","publicKey","index","parseInt","a","signing","TransportWebUSB","create","LedgerEth","name","reject","permissionWindow","window","open","addEventListener","data","success","then","Error","close","isUnlocked","path","_toLedgerPath","getAddress","res","address","chainCode","Buffer","from","bufferToHex","n","unlock","_","to","i","_addressFromIndex","push","catch","__getPage","slice","map","toLowerCase","useLedgerLive","iframeLoaded","_sendMessage","action","params","delayedPromise","withAccount","signPersonalMessage","message","unlockAccountByAddress","v","toString","length","signature","r","s","addressSignedWith","sigUtil","sig","cleanUp","checksummedAddress","options","isV4","version","sanitizeData","domain","types","primaryType","domainSeparatorHex","hashStruct","hashStructMessageHex","signEIP712HashedMessage","result","payload","error","remove","_setupIframe","value","document","createElement","src","onload","updateTransportMethod","fn","body","appendChild","tmp","split","splice","join","msg","cb","target","contentWindow","postMessage","eventListener","origin","_getOrigin","removeEventListener","increment","_getAccountsBIP44","_getAccountsLegacy","_hasPreviousTransactions","valid","balance","hex","buf","_padLeftEven","dkey","derive","str","l","substring","code","substr","String","fromCharCode","replace","apiUrl","_getApiUrl","fetch","response","json","parsedResponse","status","EventEmitter","keyring","Ledger","normalizeAddress","input","buffer","App","useState","addresses","setAddresses","setHdPath","getFirstPage","setAccountToUnlock","addAccounts","sign","currentAddress","stringToHex","alert","className","onClick","item","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.c2a04b0b.chunk.js","sourcesContent":["import { EventEmitter } from 'events';\nimport HDKey from 'hdkey';\nimport * as ethUtil from 'ethereumjs-util';\nimport * as sigUtil from 'eth-sig-util';\nimport TransportWebUSB from '@ledgerhq/hw-transport-webusb';\nimport LedgerEth from '@ledgerhq/hw-app-eth';\nimport { bufferToHex } from 'ethereumjs-util';\n\nconst pathBase = 'm';\nconst hdPathString = `${pathBase}/44'/60'/0'`;\nconst type = 'Ledger Hardware';\n\nconst BRIDGE_URL = 'https://rabbyhub.github.io/eth-ledger-bridge-keyring';\n\nconst MAX_INDEX = 1000;\nconst NETWORK_API_URLS = {\n  ropsten: 'http://api-ropsten.etherscan.io',\n  kovan: 'http://api-kovan.etherscan.io',\n  rinkeby: 'https://api-rinkeby.etherscan.io',\n  mainnet: 'https://api.etherscan.io',\n};\n\nclass LedgerBridgeKeyring extends EventEmitter {\n  constructor(opts = {}) {\n    super();\n    this.accountDetails = {};\n    this.bridgeUrl = null;\n    this.type = type;\n    this.page = 0;\n    this.perPage = 5;\n    this.unlockedAccount = 0;\n    this.hdk = new HDKey();\n    this.paths = {};\n    this.iframe = null;\n    this.network = 'mainnet';\n    this.implementFullBIP44 = false;\n    this.deserialize(opts);\n    this.msgQueue = [];\n    this.isWebUSB = true;\n    this.transport = null;\n    this.app = null;\n  }\n\n  serialize() {\n    return Promise.resolve({\n      hdPath: this.hdPath,\n      accounts: this.accounts,\n      accountDetails: this.accountDetails,\n      bridgeUrl: this.bridgeUrl,\n      implementFullBIP44: false,\n      isWebUSB: this.isWebUSB,\n    });\n  }\n\n  deserialize(opts = {}) {\n    this.hdPath = opts.hdPath || hdPathString;\n    this.bridgeUrl = BRIDGE_URL;\n    this.accounts = opts.accounts || [];\n    this.accountDetails = opts.accountDetails || {};\n    this.isWebUSB = opts.isWebUSB;\n    if (this.isWebUSB) {\n      this.makeApp();\n    }\n    if (!opts.accountDetails) {\n      this._migrateAccountDetails(opts);\n    }\n\n    this.implementFullBIP44 = opts.implementFullBIP44 || false;\n\n    // Remove accounts that don't have corresponding account details\n    this.accounts = this.accounts.filter((account) =>\n      Object.keys(this.accountDetails).includes(\n        ethUtil.toChecksumAddress(account)\n      )\n    );\n\n    return Promise.resolve();\n  }\n\n  _migrateAccountDetails(opts) {\n    if (this._isLedgerLiveHdPath() && opts.accountIndexes) {\n      for (const account of Object.keys(opts.accountIndexes)) {\n        this.accountDetails[account] = {\n          bip44: true,\n          hdPath: this._getPathForIndex(opts.accountIndexes[account]),\n        };\n      }\n    }\n\n    // try to migrate non-LedgerLive accounts too\n    if (!this._isLedgerLiveHdPath()) {\n      this.accounts\n        .filter(\n          (account) =>\n            !Object.keys(this.accountDetails).includes(\n              ethUtil.toChecksumAddress(account)\n            )\n        )\n        .forEach((account) => {\n          try {\n            this.accountDetails[ethUtil.toChecksumAddress(account)] = {\n              bip44: false,\n              hdPath: this._pathFromAddress(account),\n            };\n          } catch (e) {\n            console.log(`failed to migrate account ${account}`);\n          }\n        });\n    }\n  }\n\n  isUnlocked() {\n    return Boolean(this.hdk && this.hdk.publicKey);\n  }\n\n  setAccountToUnlock(index) {\n    this.unlockedAccount = parseInt(index, 10);\n  }\n\n  setHdPath(hdPath) {\n    // Reset HDKey if the path changes\n    if (this.hdPath !== hdPath) {\n      this.hdk = new HDKey();\n    }\n    this.hdPath = hdPath;\n  }\n\n  async makeApp(signing = false) {\n    if (!this.app && this.isWebUSB) {\n      try {\n        this.transport = await TransportWebUSB.create();\n        this.app = new LedgerEth(this.transport);\n      } catch (e) {\n        if (signing) {\n          if (\n            e.name === 'TransportWebUSBGestureRequired' ||\n            e.name === 'TransportOpenUserCancelled'\n          ) {\n            return new Promise((resolve, reject) => {\n              const permissionWindow = window.open(\n                './index.html#/request-permission?type=ledger'\n              );\n              permissionWindow?.addEventListener('message', ({ data }) => {\n                if (data.success) {\n                  this.makeApp().then(() => {\n                    resolve(null);\n                  });\n                } else {\n                  reject(new Error('Permission Rejected'));\n                }\n                permissionWindow.close();\n              });\n            });\n          }\n        }\n      }\n    }\n  }\n\n  cleanUp() {\n    this.app = null;\n    if (this.transport) this.transport.close();\n    this.transport = null;\n  }\n\n  async unlock(hdPath) {\n    if (this.isUnlocked() && !hdPath) {\n      return 'already unlocked';\n    }\n    const path = hdPath ? this._toLedgerPath(hdPath) : this.hdPath;\n    await this.makeApp();\n    const res = await this.app.getAddress(path, false, true);\n    console.log('hdPath', path);\n    console.log('res', res);\n    const { address, publicKey, chainCode } = res;\n    this.hdk.publicKey = Buffer.from(publicKey, 'hex');\n    this.hdk.chainCode = Buffer.from(chainCode, 'hex');\n    console.log('unlock publicKey', bufferToHex(this.hdk.publicKey))\n    return address;\n  }\n\n  addAccounts(n = 1) {\n    return new Promise((resolve, reject) => {\n      this.unlock()\n        .then(async (_) => {\n          const from = this.unlockedAccount;\n          const to = from + n;\n          for (let i = from; i < to; i++) {\n            const path = this._getPathForIndex(i);\n            let address;\n            if (this._isLedgerLiveHdPath()) {\n              address = await this.unlock(path);\n            } else {\n              address = this._addressFromIndex(pathBase, i);\n            }\n            this.accountDetails[ethUtil.toChecksumAddress(address)] = {\n              // TODO: consider renaming this property, as the current name is misleading\n              // It's currently used to represent whether an account uses the Ledger Live path.\n              bip44: this._isLedgerLiveHdPath(),\n              hdPath: path,\n            };\n\n            if (!this.accounts.includes(address)) {\n              this.accounts.push(address);\n            }\n            this.page = 0;\n          }\n          resolve(this.accounts);\n        })\n        .catch(reject);\n    });\n  }\n\n  getFirstPage() {\n    this.page = 0;\n    return this.__getPage(1);\n  }\n\n  getNextPage() {\n    return this.__getPage(1);\n  }\n\n  getPreviousPage() {\n    return this.__getPage(-1);\n  }\n\n  getAccounts() {\n    return Promise.resolve(this.accounts.slice());\n  }\n\n  removeAccount(address) {\n    if (\n      !this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())\n    ) {\n      throw new Error(`Address ${address} not found in this keyring`);\n    }\n    this.accounts = this.accounts.filter(\n      (a) => a.toLowerCase() !== address.toLowerCase()\n    );\n    delete this.accountDetails[ethUtil.toChecksumAddress(address)];\n  }\n\n  updateTransportMethod(useLedgerLive = false) {\n    return new Promise((resolve, reject) => {\n      // If the iframe isn't loaded yet, let's store the desired useLedgerLive value and\n      // optimistically return a successful promise\n      if (!this.iframeLoaded) {\n        this.delayedPromise = {\n          resolve,\n          reject,\n          useLedgerLive,\n        };\n        return;\n      }\n\n      this._sendMessage(\n        {\n          action: 'ledger-update-transport',\n          params: { useLedgerLive },\n        },\n        ({ success }) => {\n          if (success) {\n            resolve(true);\n          } else {\n            reject(new Error('Ledger transport could not be updated'));\n          }\n        }\n      );\n    });\n  }\n\n  signMessage(withAccount, data) {\n    return this.signPersonalMessage(withAccount, data);\n  }\n\n  // For personal_sign, we need to prefix the message:\n  async signPersonalMessage(withAccount, message) {\n    try {\n      await this.makeApp(true);\n      const hdPath = await this.unlockAccountByAddress(withAccount);\n      const res = await this.app.signPersonalMessage(\n        hdPath,\n        ethUtil.stripHexPrefix(message)\n      );\n      let v = res.v - 27;\n      v = v.toString(16);\n      if (v.length < 2) {\n        v = `0${v}`;\n      }\n      const signature = `0x${res.r}${res.s}${v}`;\n      const addressSignedWith = sigUtil.recoverPersonalSignature({\n        data: message,\n        sig: signature,\n      });\n      if (\n        ethUtil.toChecksumAddress(addressSignedWith) !==\n        ethUtil.toChecksumAddress(withAccount)\n      ) {\n        throw new Error(\n          'Ledger: The signature doesnt match the right address'\n        );\n      }\n      return signature;\n    } catch (e) {\n      throw new Error(\n        e.toString() || 'Ledger: Unknown error while signing message'\n      );\n    } finally {\n      this.cleanUp();\n    }\n  }\n\n  async unlockAccountByAddress(address) {\n    const checksummedAddress = ethUtil.toChecksumAddress(address);\n    if (!Object.keys(this.accountDetails).includes(checksummedAddress)) {\n      throw new Error(\n        `Ledger: Account for address '${checksummedAddress}' not found`\n      );\n    }\n    const { hdPath } = this.accountDetails[checksummedAddress];\n    const unlockedAddress = await this.unlock(hdPath);\n\n    // unlock resolves to the address for the given hdPath as reported by the ledger device\n    // if that address is not the requested address, then this account belongs to a different device or seed\n    if (unlockedAddress.toLowerCase() !== address.toLowerCase()) {\n      throw new Error(\n        `Ledger: Account ${address} does not belong to the connected device`\n      );\n    }\n    return hdPath;\n  }\n\n  async signTypedData(withAccount, data, options = {}) {\n    const isV4 = options.version === 'V4';\n    if (!isV4) {\n      throw new Error(\n        'Ledger: Only version 4 of typed data signing is supported'\n      );\n    }\n\n    const {\n      domain,\n      types,\n      primaryType,\n      message,\n    } = sigUtil.TypedDataUtils.sanitizeData(data);\n    const domainSeparatorHex = sigUtil.TypedDataUtils.hashStruct(\n      'EIP712Domain',\n      domain,\n      types,\n      isV4\n    ).toString('hex');\n    const hashStructMessageHex = sigUtil.TypedDataUtils.hashStruct(\n      primaryType,\n      message,\n      types,\n      isV4\n    ).toString('hex');\n\n    const hdPath = await this.unlockAccountByAddress(withAccount);\n    if (this.isWebUSB) {\n      try {\n        await this.makeApp(true);\n        const res = await this.app.signEIP712HashedMessage(\n          hdPath,\n          domainSeparatorHex,\n          hashStructMessageHex\n        );\n        let v = res.v - 27;\n        v = v.toString(16);\n        if (v.length < 2) {\n          v = `0${v}`;\n        }\n        const signature = `0x${res.r}${res.s}${v}`;\n        const addressSignedWith = sigUtil.recoverTypedSignature_v4({\n          data,\n          sig: signature,\n        });\n        if (\n          ethUtil.toChecksumAddress(addressSignedWith) !==\n          ethUtil.toChecksumAddress(withAccount)\n        ) {\n          throw new Error(\n            'Ledger: The signature doesnt match the right address'\n          );\n        }\n        return signature;\n      } catch (e) {\n        throw new Error(\n          e.toString() || 'Ledger: Unknown error while signing message'\n        );\n      } finally {\n        this.cleanUp();\n      }\n    } else {\n      const { success, payload } = await new Promise((resolve) => {\n        this._sendMessage(\n          {\n            action: 'ledger-sign-typed-data',\n            params: {\n              hdPath,\n              domainSeparatorHex,\n              hashStructMessageHex,\n            },\n          },\n          (result) => resolve(result)\n        );\n      });\n\n      if (success) {\n        let v = payload.v - 27;\n        v = v.toString(16);\n        if (v.length < 2) {\n          v = `0${v}`;\n        }\n        const signature = `0x${payload.r}${payload.s}${v}`;\n        const addressSignedWith = sigUtil.recoverTypedSignature_v4({\n          data,\n          sig: signature,\n        });\n        if (\n          ethUtil.toChecksumAddress(addressSignedWith) !==\n          ethUtil.toChecksumAddress(withAccount)\n        ) {\n          throw new Error(\n            'Ledger: The signature doesnt match the right address'\n          );\n        }\n        return signature;\n      }\n      throw new Error(\n        payload.error || 'Ledger: Unknown error while signing message'\n      );\n    }\n  }\n\n  exportAccount() {\n    throw new Error('Not supported on this device');\n  }\n\n  forgetDevice() {\n    this.accounts = [];\n    this.page = 0;\n    this.unlockedAccount = 0;\n    this.paths = {};\n    this.accountDetails = {};\n    this.hdk = new HDKey();\n  }\n\n  restart() {\n    if (this.iframe) {\n      this.iframeLoaded = false;\n      this.iframe.remove();\n    }\n    this._setupIframe();\n  }\n\n  useWebUSB(value) {\n    this.isWebUSB = value;\n  }\n\n  /* PRIVATE METHODS */\n\n  _setupIframe() {\n    this.iframe = document.createElement('iframe');\n    this.iframe.src = this.bridgeUrl;\n    this.iframe.onload = async () => {\n      // If the ledger live preference was set before the iframe is loaded,\n      // set it after the iframe has loaded\n      this.iframeLoaded = true;\n      if (this.delayedPromise) {\n        try {\n          const result = await this.updateTransportMethod(\n            this.delayedPromise.useLedgerLive\n          );\n          this.delayedPromise.resolve(result);\n        } catch (e) {\n          this.delayedPromise.reject(e);\n        } finally {\n          delete this.delayedPromise;\n        }\n      }\n      if (this.msgQueue.length > 0) {\n        this.msgQueue.forEach((fn) => fn());\n      }\n    };\n    document.body.appendChild(this.iframe);\n  }\n\n  _getOrigin() {\n    const tmp = this.bridgeUrl.split('/');\n    tmp.splice(-1, 1);\n    return tmp.join('/');\n  }\n\n  _sendMessage(msg, cb) {\n    msg.target = 'LEDGER-IFRAME';\n    if (!this.iframeLoaded) {\n      this.msgQueue.push(() => {\n        this.iframe?.contentWindow?.postMessage(msg, '*');\n      });\n    } else {\n      this.iframe?.contentWindow?.postMessage(msg, '*');\n    }\n    const eventListener = ({ origin, data }) => {\n      if (origin !== this._getOrigin()) {\n        return false;\n      }\n\n      if (data && data.action && data.action === `${msg.action}-reply` && cb) {\n        cb(data);\n        return undefined;\n      }\n\n      window.removeEventListener('message', eventListener);\n      return undefined;\n    };\n    window.addEventListener('message', eventListener);\n  }\n\n  async __getPage(increment) {\n    this.page += increment;\n\n    if (this.page <= 0) {\n      this.page = 1;\n    }\n    const from = (this.page - 1) * this.perPage;\n    const to = from + this.perPage;\n\n    await this.unlock();\n    let accounts;\n    if (this._isLedgerLiveHdPath()) {\n      // TODO: why webusb have to use bip44?\n      accounts = await this._getAccountsBIP44(from, to);\n    } else {\n      accounts = this._getAccountsLegacy(from, to);\n    }\n    return accounts;\n  }\n\n  async _getAccountsBIP44(from, to) {\n    const accounts = [];\n\n    for (let i = from; i < to; i++) {\n      const path = this._getPathForIndex(i);\n      const address = await this.unlock(path);\n      const valid = this.implementFullBIP44\n        ? await this._hasPreviousTransactions(address)\n        : true;\n      accounts.push({\n        address,\n        balance: null,\n        index: i,\n      });\n      // PER BIP44\n      // \"Software should prevent a creation of an account if\n      // a previous account does not have a transaction history\n      // (meaning none of its addresses have been used before).\"\n      if (!valid) {\n        break;\n      }\n    }\n    return accounts;\n  }\n\n  _getAccountsLegacy(from, to) {\n    const accounts = [];\n\n    for (let i = from; i < to; i++) {\n      const address = this._addressFromIndex(pathBase, i);\n      accounts.push({\n        address,\n        balance: null,\n        index: i,\n      });\n      this.paths[ethUtil.toChecksumAddress(address)] = i;\n    }\n    return accounts;\n  }\n\n  _padLeftEven(hex) {\n    return hex.length % 2 === 0 ? hex : `0${hex}`;\n  }\n\n  _normalize(buf) {\n    return this._padLeftEven(ethUtil.bufferToHex(buf).toLowerCase());\n  }\n\n  // eslint-disable-next-line no-shadow\n  _addressFromIndex(pathBase, i) {\n    console.log('generate via publicKey:', ethUtil.bufferToHex(this.hdk.publicKey));\n    const dkey = this.hdk.derive(`${pathBase}/${i}`);\n    const address = ethUtil\n      .publicToAddress(dkey.publicKey, true)\n      .toString('hex');\n    return ethUtil.toChecksumAddress(`0x${address}`);\n  }\n\n  _pathFromAddress(address) {\n    const checksummedAddress = ethUtil.toChecksumAddress(address);\n    let index = this.paths[checksummedAddress];\n    if (typeof index === 'undefined') {\n      for (let i = 0; i < MAX_INDEX; i++) {\n        if (checksummedAddress === this._addressFromIndex(pathBase, i)) {\n          index = i;\n          break;\n        }\n      }\n    }\n\n    if (typeof index === 'undefined') {\n      throw new Error('Unknown address');\n    }\n    return this._getPathForIndex(index);\n  }\n\n  _toAscii(hex) {\n    let str = '';\n    let i = 0;\n    const l = hex.length;\n    if (hex.substring(0, 2) === '0x') {\n      i = 2;\n    }\n    for (; i < l; i += 2) {\n      const code = parseInt(hex.substr(i, 2), 16);\n      str += String.fromCharCode(code);\n    }\n\n    return str;\n  }\n\n  _getPathForIndex(index) {\n    // Check if the path is BIP 44 (Ledger Live)\n    return this._isLedgerLiveHdPath()\n      ? `m/44'/60'/${index}'/0/0`\n      : `${this.hdPath}/${index}`;\n  }\n\n  _isLedgerLiveHdPath() {\n    return this.hdPath === \"m/44'/60'/0'/0/0\";\n  }\n\n  _toLedgerPath(path) {\n    return path.toString().replace('m/', '');\n  }\n\n  async _hasPreviousTransactions(address) {\n    const apiUrl = this._getApiUrl();\n    const response = await window.fetch(\n      `${apiUrl}/api?module=account&action=txlist&address=${address}&tag=latest&page=1&offset=1`\n    );\n    const parsedResponse = await response.json();\n    if (parsedResponse.status !== '0' && parsedResponse.result.length > 0) {\n      return true;\n    }\n    return false;\n  }\n\n  _getApiUrl() {\n    return NETWORK_API_URLS[this.network] || NETWORK_API_URLS.mainnet;\n  }\n}\n\nLedgerBridgeKeyring.type = type;\nexport default LedgerBridgeKeyring;\n","import { useState } from 'react';\nimport * as ethUtil from 'ethereumjs-util';\nimport { stringToHex } from 'web3-utils';\nimport Ledger from './ledger';\n\nconst BIP44_PATH = \"m/44'/60'/0'/0\";\nconst keyring = new Ledger();\n\nfunction normalizeAddress(input){\n  if (!input) {\n    return '';\n  }\n\n  if (typeof input === 'number') {\n    const buffer = ethUtil.toBuffer(input);\n    input = ethUtil.bufferToHex(buffer);\n  }\n\n  if (typeof input !== 'string') {\n    let msg = 'eth-sig-util.normalize() requires hex string or integer input.';\n    msg += ` received ${typeof input}: ${input}`;\n    throw new Error(msg);\n  }\n\n  return ethUtil.addHexPrefix(input);\n}\n\nfunction App() {\n  const [addresses, setAddresses] = useState([]);\n  \n  const getAddress = async () => {\n    await keyring.setHdPath(BIP44_PATH);\n    await keyring.unlock();\n    const addresses = await keyring.getFirstPage();\n    setAddresses(addresses);\n    await keyring.setAccountToUnlock(0);\n    keyring.addAccounts(1);\n  };\n\n  const sign = async () => {\n    const currentAddress = addresses[0];\n    await keyring.signPersonalMessage(normalizeAddress(currentAddress.address), stringToHex('test'));\n    alert('sign success');\n  }\n\n  return (\n    <div className=\"App\">\n      <div>\n        <button onClick={getAddress}>Get Addresses</button>\n        <button onClick={sign}>Sign Message</button>\n      </div>\n      <ul>\n        {\n          addresses.map(item => (<li>{item.address}</li>))\n        }\n      </ul>\n      \n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}